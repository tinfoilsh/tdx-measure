use std::io::Write;
use std::process::Command;
use anyhow::{Context, Result, anyhow};
use fs_err as fs;
use std::path::Path;
use tdx_measure::ImageConfig;
use crate::{PathResolver, PathStorage};

/// Generate a human-readable transcript of metadata files
pub fn generate_transcript(output_file: &Path, image_config: &ImageConfig, metadata_path: &Path) -> Result<()> {
    let path_resolver = PathResolver::new(metadata_path, image_config)?;
    
    let mut output = Vec::new();
    
    writeln!(output, "=== TDX Metadata Transcript ===").unwrap();
    writeln!(output, "Generated by tdx-measure").unwrap();
    writeln!(output).unwrap();
    
    // Parse and display ACPI tables using iasl
    write_acpi_tables_with_iasl(&mut output, &path_resolver.paths.acpi_tables)?;
    
    // Display command line
    writeln!(output, "=== Kernel Command Line ===").unwrap();
    writeln!(output, "{}", path_resolver.paths.cmdline).unwrap();
    writeln!(output).unwrap();
    
    // Display boot order and boot variables
    write_boot_variables(&mut output, &path_resolver.paths)?;
    
    // Display MOK variables and SBAT level for indirect boot
    if let Some(_) = image_config.indirect_boot() {
        write_mok_variables(&mut output, &path_resolver.paths)?;
        write_sbat_level(&mut output, &path_resolver.paths)?;
    }
    
    // Write to file
    fs::write(output_file, output)
        .with_context(|| format!("Failed to write transcript to {}", output_file.display()))?;
    
    println!("Transcript written to: {}", output_file.display());
    
    Ok(())
}

/// ACPI Table info extracted from header
struct AcpiTableInfo {
    signature: String,
    length: u32,
    data: Vec<u8>,
}

/// Check if a signature looks like a valid ACPI signature (printable ASCII)
fn is_valid_acpi_signature(sig: &[u8; 4]) -> bool {
    // Check if all characters are printable ASCII (32-126)
    sig.iter().all(|&b| (32..=126).contains(&b))
}

/// Split concatenated ACPI tables from QEMU fw_cfg dump (following Python script logic)
fn split_acpi_tables(data: &[u8]) -> Result<Vec<AcpiTableInfo>> {
    let mut tables = Vec::new();
    let mut offset = 0;
    
    eprintln!("Processing {} bytes of ACPI data", data.len());
    
    while offset < data.len() {
        // Ensure there's enough space for a table header (signature + length = 8 bytes)
        if offset + 8 > data.len() {
            break;
        }
        
        // Read signature (4 bytes)
        let signature_bytes = [data[offset], data[offset + 1], data[offset + 2], data[offset + 3]];
        
        // Read length (4 bytes, little-endian)
        let length = u32::from_le_bytes([
            data[offset + 4], data[offset + 5], data[offset + 6], data[offset + 7]
        ]);
        
        // Validate length
        if length == 0 {
            offset += 1;
            continue;
        }
        
        if offset + length as usize > data.len() {
            eprintln!("Warning: Table length {} exceeds remaining data at offset {}, skipping", length, offset);
            offset += 1;
            continue;
        }
        
        // Try to decode signature as ASCII and validate
        let signature = match std::str::from_utf8(&signature_bytes) {
            Ok(s) if is_valid_acpi_signature(&signature_bytes) => s.to_string(),
            _ => {
                eprintln!("Warning: Invalid signature at offset {}: {:02x?}, searching for next table", offset, signature_bytes);
                offset += 1;
                continue;
            }
        };
        
        // Extract the table data
        let table_data = data[offset..offset + length as usize].to_vec();
        
        tables.push(AcpiTableInfo {
            signature: signature.clone(),
            length,
            data: table_data,
        });
        
        eprintln!("Found ACPI table: {} ({} bytes) at offset {}", signature, length, offset);
        
        // Move to the next table (no alignment padding, just exact length)
        offset += length as usize;
    }
    
    if tables.is_empty() {
        return Err(anyhow!("No valid ACPI tables found in data"));
    }
    
    eprintln!("Successfully extracted {} tables", tables.len());
    Ok(tables)
}

/// Use iasl to disassemble ACPI tables into human-readable format
fn write_acpi_tables_with_iasl(output: &mut Vec<u8>, acpi_tables_path: &str) -> Result<()> {
    writeln!(output, "=== ACPI Tables ===").unwrap();
    writeln!(output, "Source: QEMU fw_cfg concatenated ACPI tables dump").unwrap();
    writeln!(output, "Disassembled using Intel ACPI Source Language Compiler (iasl)").unwrap();
    writeln!(output).unwrap();
    
    // Check if iasl is available
    let iasl_check = Command::new("iasl")
        .arg("-h")
        .output();
    
    if iasl_check.is_err() {
        writeln!(output, "WARNING: iasl tool not found. Install acpica-tools package for detailed ACPI analysis.").unwrap();
        writeln!(output, "Falling back to hex dump:").unwrap();
        writeln!(output).unwrap();
        write_hex_dump(output, acpi_tables_path, "ACPI Tables")?;
        return Ok(());
    }
    
    // Read and split the concatenated ACPI tables
    let acpi_data = fs::read(acpi_tables_path)
        .with_context(|| format!("Failed to read ACPI tables from {}", acpi_tables_path))?;
    
    let tables = match split_acpi_tables(&acpi_data) {
        Ok(tables) => tables,
        Err(e) => {
            writeln!(output, "WARNING: Failed to split ACPI tables: {}", e).unwrap();
            writeln!(output, "Falling back to hex dump:").unwrap();
            writeln!(output).unwrap();
            write_hex_dump(output, acpi_tables_path, "ACPI Tables")?;
            return Ok(());
        }
    };
    
    writeln!(output, "Found {} ACPI tables:", tables.len()).unwrap();
    
    // Group tables by signature for summary
    let mut signature_counts = std::collections::HashMap::new();
    for table in &tables {
        *signature_counts.entry(&table.signature).or_insert(0) += 1;
    }
    
    for (signature, count) in &signature_counts {
        writeln!(output, "  {}: {} table{}", signature, count, if *count > 1 { "s" } else { "" }).unwrap();
    }
    writeln!(output).unwrap();
    
    // Create temporary directory for iasl output
    let temp_dir = std::env::temp_dir().join(format!("tdx-measure-{}", std::process::id()));
    fs::create_dir_all(&temp_dir)
        .with_context(|| format!("Failed to create temp directory: {}", temp_dir.display()))?;
    
    // Process each table with iasl
    for (i, table) in tables.iter().enumerate() {
        writeln!(output, "=== Table {}: {} ({} bytes) ===", i + 1, table.signature, table.length).unwrap();
        
        // Generate unique filename for duplicate signatures
        let table_filename = if signature_counts[&table.signature] > 1 {
            format!("{}_{}.dat", table.signature, i + 1)
        } else {
            format!("{}.dat", table.signature)
        };
        
        let temp_table_file = temp_dir.join(&table_filename);
        fs::write(&temp_table_file, &table.data)
            .with_context(|| format!("Failed to write table {} to temp file", table.signature))?;
        
        // Run iasl on this specific table
        let iasl_output = Command::new("iasl")
            .arg("-d")  // Disassemble
            .arg(&temp_table_file)
            .current_dir(&temp_dir)
            .output()
            .with_context(|| format!("Failed to run iasl on table {}", table.signature))?;
        
        // Include iasl output
        if !iasl_output.stdout.is_empty() {
            writeln!(output, "iasl output for {}:", table.signature).unwrap();
            output.extend_from_slice(&iasl_output.stdout);
            writeln!(output).unwrap();
        }
        
        if !iasl_output.stderr.is_empty() {
            writeln!(output, "iasl warnings/errors for {}:", table.signature).unwrap();
            output.extend_from_slice(&iasl_output.stderr);
            writeln!(output).unwrap();
        }
        
        // Look for generated .dsl file for this table
        let dsl_filename = table_filename.replace(".dat", ".dsl");
        let dsl_file = temp_dir.join(&dsl_filename);
        
        if dsl_file.exists() {
            match fs::read_to_string(&dsl_file) {
                Ok(content) => {
                    writeln!(output, "Disassembled {} table:", table.signature).unwrap();
                    writeln!(output, "---").unwrap();
                    output.extend_from_slice(content.as_bytes());
                    writeln!(output, "---").unwrap();
                }
                Err(e) => {
                    writeln!(output, "Error reading disassembled {} table: {}", table.signature, e).unwrap();
                }
            }
        } else {
            writeln!(output, "No .dsl file generated for {} table. Raw hex dump:", table.signature).unwrap();
            write_raw_table_hex_dump(output, &table.data, &table.signature)?;
        }
        
        writeln!(output).unwrap();
    }
    
    // Clean up temporary directory
    if let Err(e) = fs::remove_dir_all(&temp_dir) {
        eprintln!("Warning: Failed to clean up temp directory {}: {}", temp_dir.display(), e);
    }
    
    Ok(())
}

/// Write raw table data as hex dump
fn write_raw_table_hex_dump(output: &mut Vec<u8>, data: &[u8], table_name: &str) -> Result<()> {
    writeln!(output, "{} table raw data ({} bytes):", table_name, data.len()).unwrap();
    
    let display_bytes = std::cmp::min(data.len(), 256);
    
    for (i, chunk) in data[..display_bytes].chunks(16).enumerate() {
        write!(output, "  {:04x}: ", i * 16).unwrap();
        
        // Hex bytes
        for (j, &byte) in chunk.iter().enumerate() {
            if j == 8 {
                write!(output, " ").unwrap();
            }
            write!(output, "{:02x} ", byte).unwrap();
        }
        
        // Pad remaining space
        for j in chunk.len()..16 {
            if j == 8 {
                write!(output, " ").unwrap();
            }
            write!(output, "   ").unwrap();
        }
        
        write!(output, " |").unwrap();
        
        // ASCII representation
        for &byte in chunk {
            if byte.is_ascii_graphic() || byte == b' ' {
                write!(output, "{}", byte as char).unwrap();
            } else {
                write!(output, ".").unwrap();
            }
        }
        
        writeln!(output, "|").unwrap();
    }
    
    if data.len() > display_bytes {
        writeln!(output, "  ... ({} more bytes)", data.len() - display_bytes).unwrap();
    }
    
    Ok(())
}

/// Write boot variables in human-readable format
fn write_boot_variables(output: &mut Vec<u8>, paths: &PathStorage) -> Result<()> {
    writeln!(output, "=== Boot Variables ===").unwrap();
    writeln!(output, "These are UEFI boot variables that control the boot process.").unwrap();
    writeln!(output).unwrap();
    
    write_hex_dump(output, &paths.boot_order, "Boot Order")?;
    write_hex_dump(output, &paths.boot_0000, "Boot0000")?;
    write_hex_dump(output, &paths.boot_0001, "Boot0001")?;
    write_hex_dump(output, &paths.boot_0006, "Boot0006")?;
    write_hex_dump(output, &paths.boot_0007, "Boot0007")?;
    
    writeln!(output).unwrap();
    Ok(())
}

/// Write MOK variables for indirect boot
fn write_mok_variables(output: &mut Vec<u8>, paths: &PathStorage) -> Result<()> {
    writeln!(output, "=== MOK Variables ===").unwrap();
    writeln!(output, "Machine Owner Key (MOK) variables for Secure Boot.").unwrap();
    writeln!(output).unwrap();
    
    if let Some(ref mok_list) = paths.mok_list {
        write_hex_dump(output, mok_list, "MOK List")?;
    }
    
    if let Some(ref mok_list_trusted) = paths.mok_list_trusted {
        write_hex_dump(output, mok_list_trusted, "MOK List Trusted")?;
    }
    
    if let Some(ref mok_list_x) = paths.mok_list_x {
        write_hex_dump(output, mok_list_x, "MOK List X")?;
    }
    
    writeln!(output).unwrap();
    Ok(())
}

/// Write SBAT level for indirect boot
fn write_sbat_level(output: &mut Vec<u8>, paths: &PathStorage) -> Result<()> {
    writeln!(output, "=== SBAT Level ===").unwrap();
    writeln!(output, "Secure Boot Advanced Targeting (SBAT) level information.").unwrap();
    writeln!(output).unwrap();
    
    if let Some(ref sbat_level) = paths.sbat_level {
        match fs::read_to_string(sbat_level) {
            Ok(content) => {
                writeln!(output, "SBAT Level (text content):").unwrap();
                writeln!(output, "{}", content).unwrap();
            }
            Err(_) => {
                writeln!(output, "SBAT Level (binary data):").unwrap();
                write_hex_dump(output, sbat_level, "SBAT Level")?;
            }
        }
    }
    
    writeln!(output).unwrap();
    Ok(())
}

/// Write a file as hex dump with ASCII representation
fn write_hex_dump(output: &mut Vec<u8>, file_path: &str, name: &str) -> Result<()> {
    let data = fs::read(file_path)
        .with_context(|| format!("Failed to read file: {}", file_path))?;
    
    writeln!(output, "{} ({} bytes):", name, data.len()).unwrap();
    
    if data.is_empty() {
        writeln!(output, "  [Empty file]").unwrap();
        return Ok(());
    }
    
    // Show first few bytes as hex dump
    let display_bytes = std::cmp::min(data.len(), 256);
    
    for (i, chunk) in data[..display_bytes].chunks(16).enumerate() {
        write!(output, "  {:04x}: ", i * 16).unwrap();
        
        // Hex bytes
        for (j, &byte) in chunk.iter().enumerate() {
            if j == 8 {
                write!(output, " ").unwrap();
            }
            write!(output, "{:02x} ", byte).unwrap();
        }
        
        // Pad remaining space
        for j in chunk.len()..16 {
            if j == 8 {
                write!(output, " ").unwrap();
            }
            write!(output, "   ").unwrap();
        }
        
        write!(output, " |").unwrap();
        
        // ASCII representation
        for &byte in chunk {
            if byte.is_ascii_graphic() || byte == b' ' {
                write!(output, "{}", byte as char).unwrap();
            } else {
                write!(output, ".").unwrap();
            }
        }
        
        writeln!(output, "|").unwrap();
    }
    
    if data.len() > display_bytes {
        writeln!(output, "  ... ({} more bytes)", data.len() - display_bytes).unwrap();
    }
    
    writeln!(output).unwrap();
    Ok(())
}
